"""
Copyright 2023 David Novak

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

"""
##############################
# Loss functions and helpers #
##############################
"""

import os
import warnings
warnings.filterwarnings("ignore")

os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'
import tensorflow as tf
import tensorflow.keras.backend as K

from itertools import combinations

from typing import Optional, Union
import numpy as np
import pandas as pd

LOSS_TERMS = ['recon', 'kldiv', 'group']

eps_std = tf.constant(1e-2, dtype=tf.float64)
eps_sq = eps_std ** 2
K.set_floatx('float64')

### Distance function ----

def euclidean_distance(
    x: tf.Tensor,
    y: tf.Tensor
) -> tf.Tensor:
    """
    Compute Euclidean distance between tensors

    - x, y: tensor (coordinates of a point or a row-wise batch of points) (tf.Tensor)
    """
    return K.sqrt(K.maximum(K.sum(K.square(x-y), axis=1, keepdims=False), 1e-9)) # prevent NaN

### Group loss term helpers ----

def group_norm_factor(
    x: list,
    p: list,
    f=euclidean_distance
) -> tf.Tensor:
    """
    Compute group loss normalisation factor

    Coputes denominator of a group-normalised distance. This is the sum of all pairwise distances within a group of points.

    - x: list of `n` `tf.Tensor`s (a group composed of `n` points or row-wise batches of points) (list)
    - p: optional list of tuples giving all unique pairwise combinations of point indices within the group (list)
    - f: differentiable distance function for tensors (function)
    """

    res = f(x[p[0][0]], x[p[0][1]])
    for idx in np.arange(1, len(p)):
        res += f(x[p[idx][0]], x[p[idx][1]])
    return res

def group_normalised_distance(
    x:       tf.Tensor,
    z:       tf.Tensor,
    i:       int,
    j:       int,
    x_denom: tf.Tensor,
    z_denom: tf.Tensor,
    f_hd = euclidean_distance,
    f_ld = euclidean_distance
) -> tf.Tensor:
    """
    Compute group-normalised distance

    Computes value of special distance function between points for purposes of the quartet loss.

    - x: row-wise coordinates of a batch of input points (tf.Tensor)
    - z: row-wise coordinates of a batch of latent points (tf.Tensor)
    - i, j: indices of points in `x` and `z` (int)
    - x_denom: group-normalisation factor for input points (tf.Tensor)
    - z_denom: group-normalisation factor for latent points (tf.Tensor)
    - f_hd: differentiable distance function for tensors to use in input space (function)
    - f_ld: differentiable distance function for tensors to use in latent space (function)
    """
    d_x = f_hd(x[i], x[j]) / x_denom
    d_z = f_ld(z[i], z[j]) / z_denom
    D = tf.math.pow(d_x - d_z, tf.constant(2.0, dtype=tf.float64))
    return D

def group_cost(
    x: list,
    z: list,
    p: Optional[list] = None,
    f_hd = euclidean_distance,
    f_ld = euclidean_distance
) -> tf.Tensor:
    """
    Compute batch-wise cost value for point groups in a batch

    - x: list of tensors with high-dimensional row-wise coordinates of points with the same index in their respective groups (list)
    - z: list of tensors with row-wise coordinates of corresponding low-dimensional embeddings of `x` (list)
    - p: optional list of tuples giving all unique pairwise combinations of point indices within the group (list)
    - f_hd: differentiable distance function for tensors to use in input space (function)
    - f_ld: differentiable distance function for tensors to use in latent space (function)
    """

    if p is None:
        n = len(x)
        p = list(combinations(np.arange(n), 2))

    x_denom = group_norm_factor(x, p, f_hd)
    z_denom = group_norm_factor(z, p, f_ld)

    res = group_normalised_distance(x, z, p[0][0], p[0][1], x_denom, z_denom, f_hd, f_ld)
    for idx in np.arange(1, len(p)):
        res += group_normalised_distance(x, z, p[idx][0], p[idx][1], x_denom, z_denom, f_hd, f_ld)

    res = tf.reduce_mean(res)
    return res

## Loss functions ----

def loss_recon(
        y_true: tf.Tensor,
        y_pred: tf.Tensor,
        bce:    bool = False
    ) -> tf.Tensor:
    """
    Compute reconstruction loss as mean squared error

    - y_true: batch of high-dimensional points (tf.Tensor)
    - y_pred: reconstruction of `y_true` generated by the decoder (tf.Tensor)
    - bce:    use binary cross-entropy (of scaled data) instead of mean squared error? (bool)
    """
    if bce:
        res = tf.reduce_mean(tf.keras.losses.binary_crossentropy(y_true, y_pred))
    else:
        res = tf.reduce_mean((y_true - y_pred) ** 2)
    return res

def loss_kldiv(
        z_mu:    tf.Tensor,
        z_sigma: tf.Tensor
    ) -> tf.Tensor:
    """
    Compute KL-divergence from latent prior distribution

    - z_mu:    encoded mu (mean) (tf.Tensor)
    - z_sigma: encoded sigma (mean) (tf.Tensor)
    """
    res = -0.5 * tf.reduce_mean(z_sigma + tf.math.log(eps_sq) - tf.square(z_mu) - eps_sq * tf.exp(z_sigma))
    res /= tf.shape(z_sigma)[0]
    return res

def loss_group(
        x:          tf.Tensor,
        z:          tf.Tensor,
        full_dim:   int,
        latent_dim: int,
        n:          int,
        k:          int = 4,
        n_samp:     int = 1,
        p:          Optional[list] = None,
        f_hd = euclidean_distance,
        f_ld = euclidean_distance,
        seed:       Optional[int] = 1
    ) -> tf.Tensor:
    """
    Compute group loss

    Computes the scale-agnostic k-group loss (eg. quartet loss for k=4), dividing a batch of points
    into groups of size k and quantifying preservation of normalised distances in lower-dimensional
    embedding of the original points.

    - x:       row-wise batch of high-dimensional point coordinates (tf.Tensor)
    - z:       row-wise batch of low-dimensional point coordinates (tf.Tensor)
    - n:       number of rows of `x`, `z` (int)
    - k:       group size (int)
    - n_samp:  number of partitionings to average over (int)
    - p:       optional list of tuples giving all unique pairwise combinations of point indices within the group (list)
    - f_hd:    differentiable distance function for tensors to use in input space (function)
    - f_ld:    differentiable distance function for tensors to use in latent space (function)
    - seed:    optional first random seed for shuffling (int)
    """

    nk = n // k
    idcs = tf.range(start=0, limit=n, dtype=tf.int32)

    res = tf.constant(0.0, dtype=tf.float64)

    for i_samp in range(n_samp):
        idcs_shuffled = tf.random.shuffle(idcs, seed=seed)
        x_s = tf.gather(x, idcs_shuffled)
        z_s = tf.gather(z, idcs_shuffled)

        start_idcs = [[0,0]]
        for i_k in range(k):
            start_idcs.append([nk*i_k, 0])

        x_g = [tf.slice(x_s, begin=i, size=[nk, full_dim]) for i in start_idcs]
        z_g = [tf.slice(z_s, begin=i, size=[nk, latent_dim]) for i in start_idcs]
        if seed is not None:
            seed += 1
        res += group_cost(x_g, z_g, p, f_hd, f_ld)

    res = tf.math.divide(res, tf.constant(n_samp, dtype=tf.float64))
    return res

    

